'''Two-point central difference to calculate the polarizability
and cartesian polarization. For periodic systems.
'''

#AUTHOR: Ariadni Boziki

import os
import re
import itertools as it
import numpy as np
from THeSeuSS import MapAtoms as mapatoms
from THeSeuSS import Coordinates as coords
from THeSeuSS import InputsPreparation as inputs
from THeSeuSS import CheckPeriodicvsNonPeriodic as pervsnonper
from ase.io import read



class TwoPointCentralDiff():

    def __init__(self, code: str, output_file: str, dispersion: bool, supercell: bool, restart: bool, functional: str = None):

        self.code = code
        self.output_file = output_file
        self.dispersion = dispersion
        self.supercell = supercell
        self.restart = restart
        self.functional = functional
        self.path = os.getcwd()
        self.pol = np.empty([0,6])	
        self.cartesian_pol = np.empty([0,3])
        self.element_axis_coord = np.empty([0,2])
        self.cell_dims = None
        self.commands = None
        self.volume = None
        self.CartesianPolarization = None
        self.Polarizability = None
        self.polarizability_pattern = None
        self.cartesian_polarization_pattern = None
        self.sign_atom_coord = None
        self.geometry_processor = None
        self.non_periodic = None
        self.axis_coord = 0
        self._check_periodicity()

    def _check_periodicity(self):
        """
        Setup PeriodicvsNonPeriodic class.
        """

        check_periodic_non_periodic = pervsnonper.PeriodicvsNonPeriodic(self.code, self.cell_dims, self.output_file, self.dispersion, self.restart, self.commands, self.functional)
        self.non_periodic = check_periodic_non_periodic.check_periodic_vs_non_periodic()

    def _split_line(self, line: str)-> np.ndarray:
        """
        Parses lines of text, extracting values and storing them in NumPy arrays.
        """

        larray=np.array(line.strip().split(' '))
        values=larray[larray!='']
        return values

    def _unit_cell_volume(self, path: str):
        """
        Calculates the volume of the unit cell. Since the frozen phonon approximation 
        does not involve unit cell or geometry optimizations, the volume can be obtained 
        from any FHI-aims or DFTB+ output file.
        """

        myfile = open(path, 'r')

        if self.code == 'aims':
            pattern = '| Unit cell volume'
        elif self.code == 'dftb+':
            pattern = 'Volume:'

        for line in myfile:
            if pattern in line:
                self.volume = np.float64(self._split_line(line)[-2])

    def get_volume(self)-> np.float64:
        """
        Retrieves the volume.
        """

        if 'so3lr' in self.code:
            new_path = './'
            contents = [item for item in os.listdir(new_path) if os.path.isdir(os.path.join(new_path, item))]
            first_coord_dir = next((drct for drct in contents if drct.startswith("Coord")), None)
            input_file = os.path.join(first_coord_dir, 'so3lr.xyz')
            atoms = read(input_file)
            self.volume = atoms.get_volume()
        else:
            new_path = os.path.join(self.path, 'vibrations')
            contents = [item for item in os.listdir(new_path) if os.path.isdir(os.path.join(new_path, item))]
            first_coord_dir = next((drct for drct in contents if drct.startswith("Coord")), None)
            path_output_file = os.path.join(self.path, 'vibrations', first_coord_dir, self.output_file)
            self._unit_cell_volume(path_output_file)
        print(f'VOLUME: {self.volume} A\N{SUPERSCRIPT THREE}')

        return self.volume

    def _patterns_of_polarizability(self):
        """
        Specifies the patterns used to extract polarizability and cartesian polarization 
        which are retrieved from output files generated by FHIaims and DFTB+ simulations.
        """

        if self.code == 'aims':
            self.polarizability_pattern = 'Polarizability'
            if self.non_periodic:
                self.cartesian_polarization_pattern = 'Total dipole moment'
            else:
                self.cartesian_polarization_pattern =  'Cartesian Polarization'
        elif self.code == 'dftb+':
            self.polarizability_pattern = 'Static polarisability:'
            self.cartesian_polarization_pattern = 'Dipole moment:'
        elif self.code == 'so3lr':
            self.cartesian_polarization_pattern = 'Dipole ='

    def _find_pattern(self, drcts: str)-> [np.ndarray, np.ndarray]:
        """
        Searches for specific patterns in FHI-aims and DFTB+ output files
        and extracts corresponding values. This method is designed
        for retrieving data related to Cartesian polarization
        and polarizability calculations.
        """

        self._patterns_of_polarizability()

        if self.code == 'aims':
            path = os.path.join(self.path, 'vibrations', drcts, self.output_file)
            with open(path, 'r') as f:
                lines = f.readlines()
                for line in lines:
                    if self.non_periodic:
                        if self.cartesian_polarization_pattern in line:
                            self.CartesianPolarization = np.float64(self._split_line(line)[-3:])
                    else:
                        if 'Cartesian Polarization' in line:
                            self.CartesianPolarization = np.float64(self._split_line(line)[-3:])

        elif self.code == 'dftb+':
            path_dipole_moment = os.path.join(self.path, 'vibrations', drcts, 'detailed.out')
            with open(path_dipole_moment, 'r') as ff:
                linesff = ff.readlines()
                for line in linesff:
                    if self.cartesian_polarization_pattern in line:
                        self.CartesianPolarization = np.float64(self._split_line(line)[-4:-1])
        
        if self.code == 'aims':
            if self.functional in ['pbe', 'lda']:
                path_aims = os.path.join(self.path, 'vibrations', drcts, self.output_file)
            elif self.functional not in ['pbe', 'lda']:
                drct = 'polarizability'
                path_aims = os.path.join(self.path, 'vibrations', drcts, drct, self.output_file)

            with open(path_aims, 'r') as f:
                lines = f.readlines()
                for line in lines:
                    if self.polarizability_pattern in line:
                        self.Polarizability = np.float64(self._split_line(line)[-6:])

        elif self.code == 'dftb+':
            if self.dispersion is False:
                path_dftb = os.path.join(self.path, 'vibrations', drcts, self.output_file)
            elif self.dispersion:
                drct = 'polarizability'
                path_dftb = os.path.join(self.path, 'vibrations', drcts, drct, self.output_file)

            with open(path_dftb, 'r') as f:
                lines = f.readlines()
                for index, line in enumerate(lines):
                    if self.polarizability_pattern in line:
                        pol1 = np.float64(self._split_line(lines[index+1]))
                        pol2 = np.float64(self._split_line(lines[index+2]))
                        pol3 = np.float64(self._split_line(lines[index+3]))

                        xx = pol1[0]
                        yy = pol2[1]
                        zz = pol3[2]
                        xy = pol1[1]
                        xz = pol1[2]
                        yz = pol2[2]

                        self.Polarizability = np.array([xx, yy, zz, xy, xz, yz])

        if self.code == 'so3lr':
            path = os.path.join(self.path, '', drcts, self.output_file)
            with open(path, 'r') as f:
                lines = f.readlines()
                for line in lines:
                    if self.cartesian_polarization_pattern in line:
                        self.CartesianPolarization = np.float64(self._split_line(line.replace('[','').replace(']',''))[-3:])

        return self.Polarizability, self.CartesianPolarization

    def _map_axis_coord(self, coord: str):
        """
        Returns the coordinate (x, y, z) for the mapping of equivalent coordinates.
        """

        if coord=='x':
            self.axis_coord=1
        elif coord=='y':
            self.axis_coord=2
        elif coord=='z':
            self.axis_coord=3

    def _assign_axis_to_numbers(self, sign: str)-> int:
        """
        Assigns a coefficient based on the sign provided.
        """

        if sign == '+':
            coeff = 1
        else:
            coeff = -1

        return coeff

    def _subgroups_finite_disp_drct(self)-> list:
        """
        Identifies pairs of geometry files where the same coordinate has been displaced.
        """
	
        drct = []
        new_path = os.path.join(self.path, 'vibrations') if not 'so3lr' in self.code else self.path
        contents = [item for item in os.listdir(new_path) if os.path.isdir(os.path.join(new_path, item))]
        for i in contents:
            if 'Coord' in i:
                drct.append(i)
        drct.sort(key=lambda f: int(''.join(filter(str.isdigit, f))))
        self.sign_atom_coord = []
        for dirname, item in it.combinations(drct, 2):
            atom_coord1 = dirname.split('-')[1]
            atom_coord2 = item.split('-')[1]
            if atom_coord1 == atom_coord2:
                save = dirname, item
                self.sign_atom_coord.append(save)

        return self.sign_atom_coord

    def _pol(self, disp: float):
        """
        Applies the two-point central difference method for numerical differentiation.
        This method utilizes two structures where the same coordinate has been displaced 
        to compute the derivative with respect to that coordinate.
        """

        c_diff_fraction = - 1. / (2. * disp)

        self._subgroups_finite_disp_drct()

        for item in self.sign_atom_coord:
            dir1 = item[0]      # First directory
            sign1 = dir1[-1]
            no_of_element = dir1.split('-')[2]
            self._map_axis_coord(dir1.split('-')[3]) 
            polarizability1, cart_pol1 = self._find_pattern(dir1)
            
            dir2 = item[1]     # Second directory
            sign2 = dir2[-1]
            polarizability2, cart_pol2 = self._find_pattern(dir2)

            coeff1 = self._assign_axis_to_numbers(sign1)
            coeff2 = self._assign_axis_to_numbers(sign2)

            #       Polarizability
            if not 'so3lr' in self.code:
                pol_tmp = polarizability1 * coeff1 * c_diff_fraction + polarizability2 * coeff2 * c_diff_fraction
                self.pol = np.append(self.pol,[pol_tmp], axis = 0)
            #       Cartesian Polarization
            cartesian_pol_tmp = cart_pol1 * coeff1 * c_diff_fraction + cart_pol2 * coeff2 * c_diff_fraction
            self.cartesian_pol = np.append(self.cartesian_pol,[cartesian_pol_tmp], axis = 0)

            tmp_element_axis_coord = [no_of_element, self.axis_coord]
            self.element_axis_coord = np.append(self.element_axis_coord, [tmp_element_axis_coord], axis = 0)

    def coord_conversion_cartesian_to_fractional(self):
        """
        Converts Cartesian coordinates to fractional coordinates. 
        Utilizes the ConversionUnitsCoordinates class to perform the conversion.
        """

        coordinates_conversion = coords.ConversionUnitsCoordinates(self.code)
        source_path = os.path.join(self.path, 'vibrations')

        if self.code == 'aims':
            coordinates_conversion.cartesian_to_fractional_FHIaims(source_path, self.supercell)
        if self.code == 'dftb+':
            coordinates_conversion.cartesian_to_fractional_DFTBplus(source_path, self.supercell)

    def _get_number_of_atoms(self)-> int:
        """
        Returns the number of atoms of the structure.
        """

        return self.geometry_processor.number_of_atoms()

    def calculate_pol_cart_pol(self):
        """
        Calculates the polarizability and cartesian polarization, utilizing spglibProcessor to map equivalent atoms and coordinates. 
        If a supercell is specified, adjusts the number of atoms and lines accordingly.
        """

        spglib_processor = mapatoms.spglibProcessor(self.code)
        self.pol, self.cartesian_pol = spglib_processor.prop_equivalent_atoms(self.pol, self.cartesian_pol, self.element_axis_coord)

        if self.supercell:
            if self.code == 'aims':
                geom_input = 'geometry_backup.in'
            elif self.code == 'dftb+':
                geom_input = 'geo_backup.gen'
            source_path = os.path.join(self.path, 'vibrations', geom_input)
            self.geometry_processor = inputs.GeometryProcessor(source_path, self.code)

            number_of_atoms_unit_cell = self._get_number_of_atoms()
            print(f'NUMBER OF ATOMS OF UNIT CELL: {number_of_atoms_unit_cell}')

            number_of_lines_unit_cell = 3*number_of_atoms_unit_cell

            self.pol = self.pol[:number_of_lines_unit_cell]
            self.cartesian_pol = self.cartesian_pol[:number_of_lines_unit_cell]

    def pol_cart_pol_processor(self)-> [np.ndarray, np.ndarray]:
        """
        Processes the polarizability and cartesian polarization.
        """

        if self.code == 'aims':
            self._pol(0.01)
        elif self.code == 'dftb+':
            self._pol(0.005)
        elif self.code == 'so3lr':
            self._pol(0.01)
        if self.non_periodic:
            pass
        elif self.code == 'so3lr':
            print("WARNING: Currently periodic calculation with code so3lr does not evaluate equivalent atoms! Skipping this step.")
            pass
        else:
            self.coord_conversion_cartesian_to_fractional()
            self.calculate_pol_cart_pol()

        return self.pol, self.cartesian_pol
